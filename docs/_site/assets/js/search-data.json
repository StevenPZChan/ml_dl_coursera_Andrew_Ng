var store = [{
        "title": "#0",
        "excerpt":"今天开始用jupyter notebook的形式来重写一下python challenge这个古老的python解谜网站的解法思路当然，我不是那个可以完全独立解答出来的大神，也是收集了八方的解题经验来结合自己的理解编写出来python程序的 第10题的地址在warming up     图像是一个老式电视机，上面是风景的画面，画面中间有三个数字(2, 3, 8)  图像下面有一行提示：          try to change the URL address.尝试改变URL地址       第一个想法（结合标题warming up）就是把URL地址的0.html改成1.html结果如下：   2**38 is much much larger. 所以这个也还是一个题目，应该跟画面中的数字有关尝试238.html：   No… the 38 is a little bit above the 2… 所以应该是2的38次方——2**38.html：   give the answer, not the question. 至此就豁然开朗了！ print(2 ** 38)274877906944URL改成274877906944.html，页面跳转到了map.html这回应该对了吧。还真是warming up :) 总结：这个古老的python挑战应该是个网址更改游戏，每一关都是一个网页，根据页面提示得到下一关的网址。 事实上，这一关的图片名称叫calc.jpg，这也是一个提示，以后的题目里面会用得到这种信息的。 本题代码地址0.ipynb ","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/0"
      },{
        "title": "#1",
        "excerpt":"进入正式的挑战了！ 第一题的地址在map.html 网页标题是What about making trans? 题目内容是everybody thinks twice before solving this.和一堆乱码 g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr’q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. 剩下的是通用tips：要用到各种提示、尽可能挖掘数据、不要被剧透、blabla乍一看很无头绪，事实上题目内容就这么多，尽可能都利用起来。答案肯定就藏在这堆乱码里面。结合网页标题和图片，先尝试做几个字符转换：...","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/1_map"
      },{
        "title": "#2",
        "excerpt":"继续挑战！ 第2题地址ocr.html 图片是一本打开的书 题目说明是要识别字符（ocr就是字符识别嘛），提示maybe they are in the book, but MAYBE they are in the page source. 页面最底下提示可以把URL里面的pc改成pcc看上一题的答案（其他信息是重复的tips）我暂时也没这么蠢想要对图片做OCR，毕竟清晰度不够。题目提示说要识别的字符在页面源码里嘛，我们用浏览器的view-source:看看。结果发现网页最下面有一小段文字和一超大段乱码： &lt;!–find rare characters in the mess below:–&gt;&lt;!–%%$@$^__#)^)&amp;!+]!@&amp;^}@@%%+$&amp;[(_@%+%$^@$^!+]!&amp;#)}{}}!}_]$[%}@[{_@#_^{ …–&gt; 看来这个才是真正的题目😅为了不显得那么笨拙，我就没有copy-paste了，使用python爬虫常用的requests和re模块进行数据获取： import reimport requestsresponse = requests.get('http://www.pythonchallenge.com/pc/def/ocr.html').textmessy_str = re.findall(r'&lt;!--(.*?)--&gt;', response.replace('\\n', ''))[1]根据题目意思，要找出稀有的字符。我们来做个统计： from collections import Counterc = Counter()for ch in messy_str: c[ch] += 1print(c)Counter({')': 6186, '@':...","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/2_ocr"
      },{
        "title": "#3",
        "excerpt":"继续挑战 第3题地址equality.html     网页标题是re  题目是One small letter, surrounded by EXACTLY three big bodyguards on each of its sides，意思是每边正好有3个保镖的小写字母结合图片看这个题目挺有意思，中间是一根小蜡烛，两边各有三根大蜡烛惯例先打开网页源码view-source，果然又有一长串乱码：   kAewtloYgcFQaJNhHVGxXDiQmzjfcpYbzxlWrVcqsmUbCunkfxZWDZjUZMiGqhRRiUvGmYmvnJIHEmbTMUKLECKdCt… 这回貌似只有字母了，我们先将它取出来： import reimport requestsresponse = requests.get('http://www.pythonchallenge.com/pc/def/equality.html').textmessy_str = re.findall(r'&lt;!--(.*?)--&gt;', response, re.S)[0]通过分析网页的提示，应该是让我们找出两边正好有三个大写字母的小写字母结合网页标题re，很好想到用正则就很容易： small_letters = re.findall(r'[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]', messy_str)print(''.join(small_letters))linkedlist注意是正好，所以两边还要匹配一个非大写字母（还要用[^A-Z]而不是[a-z]，因为后者匹配不到行首和行尾）。把结果输入到地址栏linkedlist.html得到   linkedlist.php 再将地址改成linkedlist.php，果然是下一题！ 总结：这一题也很简单，前提是正则玩得溜。事实上，遍历取出连续9个字符做判断也是可行的，就是代码繁琐一点。 本题代码地址3_equality.ipynb ","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/3_equality"
      },{
        "title": "#4",
        "excerpt":"继续挑战 第4题地址linkedlist.php 网页标题是follow the chain 图片是小人锯东西❓❓❓惯例打开网页源码view-source，发现注释文字： urllib may help. DON’T TRY ALL NOTHINGS, since it will never end. 400 times is more than enough. 分析一下这段话的意思。首先提示urllib会对我们有帮助，还说400次足够了，还有NOTHINGS是个什么东西，为什么要试400次？在愁眉莫展的时候发现源码里面还有一个超链接，原来点击图片是会链接到一个页面nothing=12345的 and the next nothing is 44827 这样的话，nothing是个什么东西，还有为什么400次就很明了了。 这里简单说下网页中?的意思： ?表示GET方法，后面用key1=value1&amp;key2=value2[&amp;...]的方式传递参数然后后台使用php（本题）、asp、js得方式来进行处理并返回GET结果 就不废话了，我们先试个400次，不过我们用requests不用urllib，因为前者要好用一些： import reimport requestsurl = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing='nothing = '12345'for i in range(400): response = requests.get(url + nothing).text...","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/4_linkedlist"
      },{
        "title": "#5",
        "excerpt":"继续挑战 第5题地址peak.html 网页标题是peak hell，题目是pronounce it惯例查看源码view-source，发现有一行注释和一个奇怪的标签： peak hell sounds familiar&lt;peakhell src=”banner.p”/&gt; 标签显然不是html具有的标签。结合题目内容来看，应该是让我们将peak hell读出来，说是应该很熟悉😓 其实也没有那么玄，熟悉python的话就知道这是个常用的模块，再读不出来熟悉的味道，一打开banner.p看到内容格式也就知道了。对，就是序列化的pickle模块！不多说，试下看是什么对象： import pickleimport requestsresponse = requests.get('http://www.pythonchallenge.com/pc/def/banner.p').contentbanner = pickle.loads(response)print(type(banner))print(banner[:5])&lt;class 'list'&gt;[[(' ', 95)], [(' ', 14), ('#', 5), (' ', 70), ('#', 5), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [('...","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/5_peak"
      },{
        "title": "#6",
        "excerpt":"继续挑战！从这题就开始考验发散性思维了，逐渐展现出这个挑战的恐怖。。。 第6题地址channel.html 网页标题是now there are pairs，题目内容为空惯例打开源码，除了最后面说明了是无用信息之外，只有一行隐藏信息： &lt;!– &lt;-- zip –&gt; zip正好也是图片中拉链的意思，说明这是个重要提示。而图片文件名叫channel.jpg，我们是不是可以试试channel.zip： from io import BytesIOfrom zipfile import ZipFileimport requestschannel = requests.get('http://www.pythonchallenge.com/pc/def/channel.zip').contentwith ZipFile(BytesIO(channel), 'r') as f: file_list = f.filelist with f.open('readme.txt', 'r') as f_readme: read_me = f_readme.read()print(file_list[-5:])print(read_me.decode())[&lt;ZipInfo filename='99460.txt' compress_type=deflate file_size=21 compress_size=23&gt;, &lt;ZipInfo filename='99714.txt' compress_type=deflate file_size=21 compress_size=23&gt;, &lt;ZipInfo filename='99775.txt' compress_type=deflate file_size=21 compress_size=23&gt;,...","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/6_channel"
      },{
        "title": "#7",
        "excerpt":"继续挑战！貌似要开始用到图像处理了。 第7题地址oxygen.html 网页标题是smarty，网页源码中没有隐藏信息看网页标题是smarty，自作聪明的人？不懂有什么深层的含义。不过没有其他信息的话，题目应该藏在图中。这张图中间有一条灰黑色跟条形码类似的东东，怀疑就是类似密码的东西，我们先试着把它提取出来。 from collections import Counterfrom io import BytesIOfrom itertools import productimport requestsfrom PIL import Imageresponse = requests.get('http://www.pythonchallenge.com/pc/def/oxygen.png')img = Image.open(BytesIO(response.content))gray_points = {}c = Counter()for x, y in product(range(img.width), range(img.height)): pcolor = img.getpixel((x, y)) # 灰点实际上是RGB三通道值相等 if pcolor[0] == pcolor[1] == pcolor[2]: gray_points[(x, y)] = pcolor[0] c[y] += 1print(c)Counter({43: 608,...","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/7_oxygen"
      },{
        "title": "#8",
        "excerpt":"继续挑战 第8题地址integrity.html     网页标题是working hard?，题目是Where is the missing link?，源码中有两行隐藏信息：          un: ‘BZh91AY&amp;SYA\\xaf\\x82\\r\\x00\\x00\\x01\\x01\\x80\\x02\\xc0\\x02\\x00 \\x00!\\x9ah3M\\x07&lt;]\\xc9\\x14\\xe1BA\\x06\\xbe\\x084’pw: ‘BZh91AY&amp;SY\\x94$|\\x0e\\x00\\x00\\x00\\x81\\x00\\x03$ \\x00!\\x9ah3M\\x13&lt;]\\xc9\\x14\\xe1BBP\\x91\\xf08’       图片上是以一个&lt;area&gt;区域画出来一个超链接，点击之后提示要输入用户名和密码。这应该是题目的基本意思。而这个区域刚好描绘的是图中的蜜蜂，结合bee和网页标题working hard，应该意思是busy。再看看源码中的隐藏信息，应该指的是username和password，估计就是提示要输入的部分。 直接拿这一堆乱码去试肯定是行不通的别说，我还真试了几次。正确做法应该是要解读这个busy的意思，结合这个乱码（BZh开头），应该指的是bzip2压缩编码，python对应有bz2的包可以简易处理。 from bz2 import decompressprint('username:', decompress(b'BZh91AY&amp;SYA\\xaf\\x82\\r\\x00\\x00\\x01\\x01\\x80\\x02\\xc0\\x02\\x00 \\x00!\\x9ah3M\\x07&lt;]\\xc9\\x14\\xe1BA\\x06\\xbe\\x084').decode())print('password:', decompress(b'BZh91AY&amp;SY\\x94$|\\x0e\\x00\\x00\\x00\\x81\\x00\\x03$ \\x00!\\x9ah3M\\x13&lt;]\\xc9\\x14\\xe1BBP\\x91\\xf08').decode())username: hugepassword: file将解码后的结果输入到提示框里面点确定，来到下一题good.html 总结：题目跟图像处理无关，倒是又介绍了一种压缩编码和对应的python包。 本题代码地址8_integrity.ipynb ","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/8_integrity"
      },{
        "title": "#9",
        "excerpt":"来到了新的一片区域，继续挑战！ 第9题地址good.html（本题开始需要密码，密码是通过上一个区域最后一题得到的） 网页标题是connect the dots，题目为空，源码中有包含一大串数字的隐藏代码，隐藏的题目是 first+second=? 图片中是有一些点，但根据题目一贯的做法，应该是跟隐藏内容有关。隐藏内容是一堆数字，但大部分是三位数，结合connect the dots，这些数应该就是坐标值，而我们要把它们连起来。 from io import BytesIOimport reimport requestsfrom PIL import Image, ImageDrawwith requests.Session() as sess: sess.auth = ('huge', 'file') response = sess.get('http://www.pythonchallenge.com/pc/return/good.html').text hided_text = re.search(r'first:(?P&lt;first&gt;.*?)second:(?P&lt;second&gt;.*?)--&gt;', response.replace('\\n', '')) first = [int(x) for x in re.findall(r'(\\d+)', hided_text.group('first'))] second = [int(x) for x in re.findall(r'(\\d+)', hided_text.group('second'))]...","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/9_good"
      },{
        "title": "#10",
        "excerpt":"继续挑战 第10题地址bull.html 网页标题是what are you looking at?，题目内容是len(a[30]) = ?，源码里面没有隐藏内容看到上一题画出来的牛的真面目了！同样以牛的轮廓圈起来的区域有一个超链接，点进去是这样的内容 a = [1, 11, 21, 1211, 111221, 这样的话，结合题目内容一看，思路也是很清晰的。a是一个数列，我们要求出a[30]的位数。关键是a数列是什么规律呢？懂行的一看就懂了，反而是数学太好的想不出来，因为它不是任何的数学规律。 外观数列（Look-and-say sequence）第n项描述了第n-1项的数字分布。它以1开始： 1：读作1个“1”，即11 11：读作2个“1”，即21 21：读作1个“2”，1个“1”，即1211 1211：读作1个“1”，1个“2”，2个“1”，即111221 111221：读作3个“1”，2个“2”，1个“1”，即312211 1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, … （OEIS中的数列A005150） From wikipedia.org 废话不多说，直接上代码，用正则应该会容易一些： from itertools import isliceimport redef look_and_say(): num = '1' while True: yield num...","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/10_bull"
      },{
        "title": "#11",
        "excerpt":"继续挑战 第11题地址5808.html 网页标题是odd even，题目内容为空，源码也没有隐藏内容显然图片本身就是题目，而提示信息只有网页标题这个odd even——奇偶。初一看，图片像是两张不同的图片以某种方式叠加而得，但放大一看，其实每隔一个像素就会有一个略黑的像素，结合标题odd even，估计是让我们将像素点的坐标按奇偶分下类： from io import BytesIOfrom itertools import productimport requestsfrom PIL import Imagewith requests.Session() as sess: sess.auth = ('huge', 'file') response = sess.get('http://www.pythonchallenge.com/pc/return/cave.jpg').content img = Image.open(BytesIO(response))img_new = Image.new('RGB', img.size)for x, y in product(range(img.width), range(img.height)): new_x = x // 2 + (x % 2) * (img.width //...","categories": ["python"],
        "tags": ["python","challenge"],
        "url": "http://localhost:4000/pythonchallenge/python/11_5808"
      }]
